//
// Created by machiry on 12/28/16.
//

#ifndef PROJECT_VULNERABILITYWARNING_H
#define PROJECT_VULNERABILITYWARNING_H

#include "llvm/IR/DebugInfoMetadata.h"
#include "llvm/IR/DebugLoc.h"
#include "llvm/Pass.h"
#include "llvm/Analysis/AliasSetTracker.h"
#include "llvm/IR/InstVisitor.h"
#include "llvm/IR/CFG.h"
#include "../../../../Utils/include/CFGUtils.h"


using namespace llvm;
namespace DRCHECKER {
    /***
     * This represents a common class for all vulnerability warnings.
     */
    class VulnerabilityWarning {
    public:
        std::set<std::vector<InstLoc*>*> traces;
        std::string warning_string;
        InstLoc *targetLoc;
        std::string found_by;

        VulnerabilityWarning(InstLoc *targetLoc, std::set<std::vector<InstLoc*>*> *srcTrace,
                             std::string warningMsg, std::string found_by) {
            this->targetLoc = targetLoc;
            this->warning_string = warningMsg;
            if (srcTrace && !srcTrace->empty() && targetLoc) {
                //First append the warned inst to the trace.
                bool inserted = false;
                for (std::vector<InstLoc*> *tr : *srcTrace) {
                    if (!tr) {
                        continue;
                    }
                    if (tr->size() == 0 || (*tr)[tr->size()-1] != targetLoc) {
                        tr->push_back(targetLoc);
                        inserted = true;
                    }
                }
                this->traces.insert(srcTrace->begin(), srcTrace->end());
            }
            this->found_by = found_by;
        }

        //A wrapper for convenience and compatiability.
        VulnerabilityWarning(InstLoc *targetLoc, std::vector<InstLoc*> *srcTrace,
                             std::string warningMsg, std::string found_by): 
        VulnerabilityWarning(targetLoc,(std::set<std::vector<InstLoc*>*>*)nullptr,warningMsg,found_by) {
            if (srcTrace && targetLoc) {
                //First append the warned inst to the trace.
                if (srcTrace->empty() || (*srcTrace)[srcTrace->size()-1] != targetLoc) {
                    srcTrace->push_back(targetLoc);
                }
                //REcord the trace.
                this->traces.insert(srcTrace);
            }
        }

        /***
         * Print complete warning message to the provided raw stream.
         * @param O raw stream to which the output should be written to.
         */
        virtual void printCompleteWarning(llvm::raw_ostream& O) const;

        /***
         *  Print a normal warning message to the provided output stream.
         * @param O raw stream to which the output should be written to.
         */
        virtual void printWarning(llvm::raw_ostream& O);

        /***
         *  get the trace of the call sites to this function where the warning was
         *  generated.
         * @return pointer to the list of instruction representing call sites.
         */
        virtual std::vector<Instruction*> *getCallSiteTrace() {
            if (this->targetLoc && this->targetLoc->ctx) {
                return this->targetLoc->ctx->callSites;
            }
            return nullptr;
        }

        virtual bool isSameVulWarning(VulnerabilityWarning *toCheck) {
            if(toCheck != nullptr) {
                return this->targetLoc == toCheck->targetLoc &&
                       this->warning_string.compare(toCheck->warning_string) == 0 &&
                       this->found_by.compare(toCheck->found_by) == 0;
            }
            return false;
        }
    };
}

#endif //PROJECT_VULNERABILITYWARNING_H
